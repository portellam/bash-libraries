#!/bin/bash sh

#
# Filename:         bashlib-globals
# Description:      File operation and validation
# Author(s):        Alex Portell <github.com/portellam>
# Maintainer(s):    Alex Portell <github.com/portellam>
#

# <remarks> Using </remarks>
# <code>
    source bashlib-globals
    source bashlib-vars
# </code>

# <code>
    # <summary> Check if two given files are the same. If true, pass. </summary>
    # <parameter name=$1> string: the file </parameter>
    # <parameter name=$2> string: the other file </parameter>
    # <returns> exit code </returns>
    function AreEqualFiles
    {
        IsFile $2 || return $?
        IsFile $1 || return $?

        # <params>
        local readonly var_command='cmp -s $1 $2'
        # </params>

        eval "${var_command}" || return 1
        return 0
    }

    # # TODO: needs work!
    # # <summary> Create latest backup of given file (do not exceed given maximum count). </summary>
    # # <parameter name=$1> string: the file </parameter>
    # # <returns> exit code </returns>
    # function BackupFile
    # {
    #     function BackupFile_Main
    #     {
    #         # TODO: need to reverse pad out zeros, such that we can get the proper integer.

    #         IsFile $1 || return $?

    #         # <params>
    #         declare -ir int_max_count=5
    #         local readonly str_suffix=".old"
    #         local readonly var_get_backups='ls '"${str_dir}"' | grep '$1' | grep -i '"${str_suffix}"' | uniq | sort -V'
    #         local readonly var_pad_zeros='str_index=$( printf %03d "${int_index}" )'
    #         declare -a arr_dir=( $( eval "${var_get_backups}" ) )
    #         declare -i int_index=1
    #         # </params>

    #         # <remarks> Get index of oldest backup file. </remarks>
    #         local str_oldest_file="${arr_dir[0]}"
    #         str_oldest_file="${str_oldest_file%%"${str_suffix}"*}"
    #         str_index="${str_oldest_file##*0}"
    #         IsNum "$str_index" && int_index="${str_index}" || int_index=1
    #         eval "${var_pad_zeros}"

    #         # <remarks> If none exist, create backup. </remarks>
    #         if ! IsArray arr_dir; then
    #             cp $1 "${1}.${str_index}${str_suffix}" || return 1
    #         fi

    #         # <remarks> If newest backup is same as file, exit. </remarks>
    #         if AreEqualFiles $1 "${arr_dir[-1]}"; then
    #             return 0
    #         fi

    #         # <remarks> If amount of backups exceeds maximum, delete oldest backup. </remarks>
    #         if [[ "${#arr_dir[@]}" -ge "${int_max_count}" ]]; then
    #             echo "deleted file"
    #             DeleteFile "${arr_dir[0]}" || return $?
    #         fi

    #         # <remarks> Get index of newest backup file. </remarks>
    #         local str_oldest_file="${arr_dir[-1]}"
    #         str_oldest_file="${str_oldest_file%%"${str_suffix}"*}"
    #         str_index="${str_oldest_file##*.}"
    #         IsNum "$str_index" && int_index="${str_index}" || int_index=1
    #         (( int_index++ ))
    #         echo $int_index
    #         eval "${var_pad_zeros}"

    #         # <remarks> Create backup. </remarks>
    #         cp $1 "${1}.${str_index}${str_suffix}" || return 1

    #         return 0
    #     }

    #     # <params>
    #     local readonly str_output="Creating backup file..."
    #     # </params>

    #     echo -e "${str_output}"
    #     BackupFile_Main $1
    #     PrintPassOrFail "${str_output}"
    #     return "${int_exit_code}"
    # }

    # <summary> Create a directory. </summary>
    # <param name=$1> string: the directory </param>
    # <returns> exit code </returns>
    function CreateDir
    {
        IsString $1 || return $?
        IsDir $1 &> /dev/null && return 0

        # <params>
        local readonly str_fail="${var_prefix_fail} Could not create directory '${1}'."
        local readonly var_command='mkdir -p $1 &> /dev/null'
        # </params>

        if ! eval "${var_command}"; then
            echo -e "${str_fail}"
            return 1
        fi

        return 0
    }

    # <summary> Create a file. </summary>
    # <param name=$1> string: the file </param>
    # <returns> exit code </returns>
    function CreateFile
    {
        IsString $1 || return $?
        IsFile $1 &> /dev/null && return 0

        # <params>
        local readonly str_fail="${var_prefix_fail} Could not create file '${1}'."
        local readonly var_command='touch '"$1"' &> /dev/null'
        # </params>

        if ! eval "${var_command}"; then
            echo -e "${str_fail}"
            return 1
        fi

        return 0
    }

    # <summary> Delete a directory. </summary>
    # <param name=$1> string: the file </param>
    # <returns> exit code </returns>
    function DeleteDir
    {
        IsString $1 || return $?
        IsDir $1 &> /dev/null || return 1

        # <params>
        local readonly str_fail="${var_prefix_fail} Could not delete directory '${1}'."
        local readonly var_command='rm -r '"$1"' &> /dev/null'
        # </params>

        if ! eval "${var_command}"; then
            echo -e "${str_fail}"
            return 1
        fi

        return 0
    }

    # <summary> Delete a file. </summary>
    # <param name=$1> string: the file </param>
    # <returns> exit code </returns>
    function DeleteFile
    {
        IsString $1 || return $?
        IsFile $1 &> /dev/null || return 1

        # <params>
        local readonly str_fail="${var_prefix_fail} Could not delete file '${1}'."
        local readonly var_command='rm '"$1"' &> /dev/null'
        # </params>

        if ! eval "${var_command}"; then
            echo -e "${str_fail}"
            return 1
        fi

        return 0
    }

    # <summary> Create a file. If true, pass. </summary>
    # <param name=$1> string: the file </param>
    # <param name=$2> string: the line </param>
    # <returns> exit code </returns>
    function FindLine
    {
        IsString $2 || return $?
        IsFile $1 || return $?

        # <params>
        local readonly var_command='! -z $( grep -iF $2 $1 )'
        # </params>

        if [[ -z $( grep -iF $2 $1 ) ]]; then
            return 1
        fi

        return 0
    }

    # <summary> Check if the directory exists. If true, pass. </summary>
    # <param name=$1> string: the directory name </param>
    # <returns> exit code </returns>
    function IsDir
    {
        IsString $1 || return $?

        # <params>
        local readonly str_fail="${var_prefix_error} File '${1}' is not a directory."
        # </params>

        if [[ ! -d $1 ]]; then
            echo -e "${str_fail}"
            return "${int_code_dir_is_null}"
        fi

        return 0
    }

    # <summary> Check if the file exists. If true, pass. </summary>
    # <param name=$1> string: the file name </param>
    # <returns> exit code </returns>
    function IsFile
    {
        IsString $1 || return $?

        # <params>
        local readonly str_fail="${var_prefix_error} '${1}' is not a file."
        # </params>

        if ! IsDir $1 &> /dev/null && [[ ! -e $1 ]]; then
            echo -e "${str_fail}"
            return "${int_code_dir_is_null}"
        elif IsDir $1 &> /dev/null; then
            echo -e "${str_fail}"
            return "${int_code_dir_is_null}"
        else
            return 0
        fi
    }

    # <summary> Check if the file is executable. If true, pass. </summary>
    # <param name=$1> string: the file name </param>
    # <returns> exit code </returns>
    function IsFileExecutable
    {
        IsFile $1 || return $?

        # <params>
        local readonly str_fail="${var_prefix_error} File '${1}' is not executable."
        # </params>

        if [[ ! -x $1 ]]; then
            echo -e "${str_fail}"
            return "${int_code_file_is_not_executable}"
        fi

        return 0
    }

    # <summary> Check if the file is readable. If true, pass. </summary>
    # <param name=$1> string: the file name </param>
    # <returns> exit code </returns>
    function IsFileReadable
    {
        IsFile $1 || return $?

        # <params>
        local readonly str_fail="${var_prefix_error} File '${1}' is not readable."
        # </params>

        if [[ ! -r $1 ]]; then
            echo -e "${str_fail}"
            return "${int_code_file_is_not_readable}"
        fi

        return 0
    }

    # <summary> Check if the file is writable. If true, pass. </summary>
    # <param name=$1> string: the file name </param>
    # <returns> exit code </returns>
    function IsFileWritable
    {
        IsFile $1 || return $?

        # <params>
        local readonly str_fail="${var_prefix_error} File '${1}' is not writable."
        # </params>

        if [[ ! -w $1 ]]; then
            echo -e "${str_fail}"
            return "${int_code_file_is_not_writable}"
        fi

        return 0
    }

    # <summary> Overwrite output to a file. Declare inherited params before calling this function. </summary>
    # <paramref name=$1> string: the name of the array </paramref>
    # <param name=$2> string: the name of the file </param>
    # <returns> exit code </returns>
    function OverwriteFile
    {
        IsArray $1 || return $?
        DeleteFile $2
        CreateFile $2 || return $?
        WriteFile $1 $2
        return $?
    }

    # <summary> Output a file. </summary>
    # <param name=$1> string: the file </param>
    # <returns> exit code </returns>
    function PrintFile
    {
        IsFile $1 || return $?

        # <params>
        IFS=$'\n'
        declare -a arr_print_file=( )
        local readonly str_output="Contents for file ${var_yellow}'${1}'${var_reset_color}:"
        # </params>

        ReadFile "arr_print_file" $1 || return $?
        PrintArray "arr_print_file"
        return $?
    }

    # <summary> Read input from a file. Declare inherited params before calling this function. </summary>
    # <paramref name=$1> string: the name of the array </paramref>
    # <param name=$2> string: the name of the file </param>
    # <returns> exit code </returns>
    function ReadFile
    {
        IsFile $2 || return $?
        IsString $1 || return $?

        # <params>
        IFS=$'\n'
        local readonly str_fail="${var_prefix_fail} Could not read from file '${2}'."
        local readonly var_mapfile='mapfile -t < <( cat '"$2"' )'
        local readonly var_set_param="$1"'=( "${MAPFILE[@]}" )'
        # </params>

        if ! eval "${var_mapfile}" || ! IsArray "MAPFILE" &> /dev/null; then
            echo -e "${str_fail}"
            return 1
        fi

        eval "${var_set_param}"
        return $?
    }

    # # TODO: needs work!
    # # <summary> Restore latest valid backup of given file. </summary>
    # # <parameter name=$1> string: the name of the file </param>
    # # <returns> exit code </returns>
    # function RestoreFile
    # {
    #     function RestoreFile_Main
    #     {
    #         IsFile $1 || return $?

    #         # <params>
    #         local bool=false
    #         local readonly str_dir=$( dirname $1 )
    #         local readonly str_suffix=".old"
    #         var_command='ls "${str_dir}" | grep $1 | grep $str_suffix | uniq | sort -rV'
    #         declare -a arr_dir=( $( eval "${var_command}" ) )
    #         # </params>

    #         IsArray "arr_dir" || return $?

    #         for var_element in "${arr_dir[@]}"; do
    #             IsFile "${var_element}" && cp "${var_element}" $1 && return 0
    #         done

    #         return 1
    #     }

    #     # <params>
    #     local readonly str_output="Restoring backup file..."
    #     # </params>

    #     echo -e "${str_output}"
    #     RestoreFile_Main $1
    #     PrintPassOrFail "${str_output}"
    #     return "${int_exit_code}"
    # }

    # <summary> Write output to a file. Declare inherited params before calling this function. </summary>
    # <paramref name=$1> string: the name of the array </paramref>
    # <param name=$2> string: the name of the file </param>
    # <returns> exit code </returns>
    function WriteFile
    {
        IsFile $2 || return $?
        IsArray $1 || return $?

        # <params>
        local readonly str_fail="${var_prefix_fail} Could not write to file '${1}'."
        local readonly var_set_file='printf "%s\n" "${'$1'[@]}" >> $2'
        # </params>

        if ! eval "${var_set_file}"; then
            echo -e "${str_fail}"
            return 1
        fi

        return 0
    }
# </code>